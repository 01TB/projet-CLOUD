package web.backend.project.features.sync.services;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.jpa.repository.JpaRepository;
import web.backend.project.entities.SyncableEntity;
import web.backend.project.entities.UseExistingOrGenerateId;
import web.backend.project.entities.dto.FirebaseSerializable;

import jakarta.persistence.EntityManager;

import java.util.Map;
import java.util.function.Supplier;

/**
 * Handler générique pour un type d'entité spécifique
 * Encapsule le repository, le factory et la logique de résolution des relations
 * 
 * @param <E> Type de l'entité
 * @param <D> Type du DTO
 */
public class EntityTypeHandler<E extends SyncableEntity<D>, D extends FirebaseSerializable> {

    private static final Logger logger = LoggerFactory.getLogger(EntityTypeHandler.class);

    private final String entityType;
    private final JpaRepository<E, Integer> repository;
    private final Supplier<E> entityFactory;
    private final Supplier<D> dtoFactory;
    private final RelationResolver<E, D> relationResolver;

    /**
     * Interface fonctionnelle pour résoudre les relations d'une entité
     */
    @FunctionalInterface
    public interface RelationResolver<E, D> {
        /**
         * Résout et assigne les relations de l'entité depuis le DTO
         * Par exemple: charge Utilisateur, Entreprise, etc. depuis leurs IDs
         */
        void resolveRelations(E entity, D dto);
    }

    public EntityTypeHandler(
            String entityType,
            JpaRepository<E, Integer> repository,
            Supplier<E> entityFactory,
            Supplier<D> dtoFactory,
            RelationResolver<E, D> relationResolver) {
        this.entityType = entityType;
        this.repository = repository;
        this.entityFactory = entityFactory;
        this.dtoFactory = dtoFactory;
        this.relationResolver = relationResolver;
    }

    /**
     * Constructeur simplifié pour les entités sans relations
     */
    public EntityTypeHandler(
            String entityType,
            JpaRepository<E, Integer> repository,
            Supplier<E> entityFactory,
            Supplier<D> dtoFactory) {
        this(entityType, repository, entityFactory, dtoFactory, (e, d) -> {
        });
    }

    public String getEntityType() {
        return entityType;
    }

    public JpaRepository<E, Integer> getRepository() {
        return repository;
    }

    /**
     * Crée une nouvelle instance de l'entité
     */
    public E createEntity() {
        return entityFactory.get();
    }

    /**
     * Crée un DTO depuis les données Firebase
     */
    public D createDTOFromFirebase(Map<String, Object> firebaseData) {
        D dto = dtoFactory.get();
        dto.fromFirebaseMap(firebaseData);
        return dto;
    }

    /**
     * Met à jour ou crée une entité depuis les données Firebase
     * Uses merge semantics to properly handle detached entities and avoid
     * StaleObjectStateException
     * 
     * Note: For new entities from Firebase, we preserve the Firebase ID
     * since the database uses GENERATED BY DEFAULT AS IDENTITY (accepts explicit
     * IDs).
     * This is critical for referential integrity between related entities.
     */
    public E updateOrCreate(Map<String, Object> firebaseData, EntityManager entityManager) {
        D dto = createDTOFromFirebase(firebaseData);
        Integer id = dto.getId();

        logger.debug("Processing {} with id: {}", entityType, id);

        E entity;
        boolean isNewEntity = false;

        if (id != null) {
            // Try to find existing entity using EntityManager for better control
            E existing = entityManager.find(getEntityClass(), id);
            if (existing != null) {
                entity = existing;
                logger.debug("Found existing entity for id: {}", id);
            } else {
                // Entity doesn't exist in database, create new one
                // DON'T set the ID here — it will be passed via ThreadLocal to the generator
                // Setting ID on entity would cause Hibernate to treat it as detached
                entity = createEntity();
                isNewEntity = true;
                logger.debug("Creating new entity with Firebase id: {}", id);
            }
        } else {
            // No ID provided, create new entity (database will auto-generate via IDENTITY)
            entity = createEntity();
            isNewEntity = true;
            logger.debug("Creating new entity without id (will be auto-generated)");
        }

        // Update simple fields from DTO (excluding ID for new entities)
        entity.updateFromDTO(dto);

        // Defensive: ensure we never merge an entity with a null ID
        // (Hibernate can throw "cannot generate an EntityKey when id is null")
        if (!isNewEntity && entity.getId() == null) {
            logger.warn("Entity {} resolved as existing but has null id after update; treating as new", entityType);
            isNewEntity = true;
        }

        // Mark as synced since it comes from Firebase
        entity.setSynchro(true);

        // Resolve relations - wrap in try-catch to prevent dirty session state on
        // failure
        try {
            relationResolver.resolveRelations(entity, dto);
        } catch (Exception e) {
            // Clear the entity from the persistence context if relation resolution fails
            if (isNewEntity) {
                entityManager.detach(entity);
            }
            throw new RuntimeException("Failed to resolve relations for " + entityType + ": " + e.getMessage(), e);
        }

        E savedEntity;
        try {
            if (isNewEntity) {
                // For new entities with explicit Firebase ID, pass it via ThreadLocal
                // so the custom generator uses it (without setting it on the @Id field)
                if (id != null) {
                    UseExistingOrGenerateId.setForcedId(id);
                }
                try {
                    entityManager.persist(entity);
                } finally {
                    UseExistingOrGenerateId.clearForcedId();
                }
                savedEntity = entity;
                logger.debug("Persisted new entity with id: {}", savedEntity.getId());
            } else {
                // Existing entity → merge
                savedEntity = entityManager.merge(entity);
                logger.debug("Merged entity with id: {}", savedEntity.getId());
            }
            // Flush immediately to catch any database errors and get the generated ID
            entityManager.flush();
        } catch (Exception e) {
            // Detach the entity to prevent it from being flushed later
            if (entity != null && entity.getId() != null) {
                entityManager.detach(entity);
            } else {
                // If id is null, detach would trigger "cannot generate an EntityKey"
                entityManager.clear();
            }
            throw new RuntimeException("Failed to save entity " + entityType + ": " + e.getMessage(), e);
        }

        logger.debug("Successfully saved entity {} with id: {}", entityType, savedEntity.getId());
        return savedEntity;
    }

    /**
     * Legacy method for backward compatibility - delegates to new method
     */
    public E updateOrCreate(Map<String, Object> firebaseData) {
        throw new UnsupportedOperationException(
                "updateOrCreate requires EntityManager. Use updateOrCreate(firebaseData, entityManager) instead.");
    }

    /**
     * Returns the entity class for EntityManager operations
     */
    @SuppressWarnings("unchecked")
    private Class<E> getEntityClass() {
        // Create a temporary entity to get its class
        E temp = entityFactory.get();
        return (Class<E>) temp.getClass();
    }

    /**
     * Résout les relations de l'entité
     */
    public void resolveRelations(E entity, D dto) {
        relationResolver.resolveRelations(entity, dto);
    }
}
